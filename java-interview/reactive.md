[Вопросы для собеседования](../README.md)

# Реактивность

+ [Реактивное программирование суть](reactive.md#Реактивное-программирование-суть)
+ [Основные виды потерь на блокирующем типе программирования](reactive.md#Основные-виды-потерь-на-блокирующем-типе-программирования)
+ [Понятие backpressure(обратное давление). Что оно дает.](reactive.md#Понятие-backpressure-обратное-давление-Что-оно-дает)
+ [При каком количестве запросов и нагрузке имеет реактивно построенное приложение начинает выигровать у приложения с блокироющим типом запросов](reactive.md#При-каком-количестве-запросов-и-нагрузке-имеет-реактивно)
+ [Основные библиотеки  ](reactive.md#Основные-библиотеки)


## Реактивное программирование суть


Реактивное программирование (Reactive Programming) - это парадигма программирования, направленная на создание асинхронных,
неблокирующих и отзывчивых приложений. Основная идея реактивного программирования заключается в том, чтобы строить приложения
таким образом, чтобы они могли эффективно обрабатывать потоки данных и событий.

Основные принципы реактивного программирования:

1. Асинхронность: В реактивном программировании операции выполняются асинхронно, то есть без явного ожидания завершения. 
Это позволяет использовать ресурсы более эффективно и улучшает отзывчивость системы.

2. Неблокирующий код: Код написан таким образом, чтобы он не блокировал исполнение потоков во время ожидания ввода-вывода 
(I/O) или выполнения других долгих операций. Это позволяет обрабатывать большое количество запросов и событий одновременно 
без необходимости создания большого числа потоков.

3. Обработка потоков данных: Реактивное программирование обычно работает с потоками данных и событий. Оно обеспечивает 
механизмы для управления, обработки и обработки потоков данных, таких как потоки данных (streams) и реактивные последовательности (reactive sequences).

4. Обратная связь и реакция на изменения: Реактивное программирование поддерживает обратную связь и реагирует на изменения 
в данных или состоянии системы. Это позволяет строить адаптивные системы, которые могут адекватно реагировать на динамические условия.

Преимущества реактивного программирования перед блокирующим:

1. Отзывчивость: Реактивные приложения имеют лучшую отзывчивость благодаря асинхронной и неблокирующей природе. Они могут
обрабатывать большое количество запросов и событий параллельно без задержек.

2. Масштабируемость: Благодаря эффективному использованию ресурсов и параллелизации операций, реактивные приложения легче 
масштабируются и могут обрабатывать больший объем работы.

3. Отказоустойчивость: Реактивные системы обычно более устойчивы к сбоям и перегрузкам благодаря своей способности эластично 
адаптироваться к изменяющимся условиям и обрабатывать ошибки асинхронно.

4. Производительность: Использование асинхронных и неблокирующих операций позволяет повысить производительность системы 
за счет более эффективного использования ресурсов и параллелизации операций.

В целом, реактивное программирование способствует созданию более отзывчивых, масштабируемых и устойчивых систем, 
способных эффективно обрабатывать большие объемы данных и запросов.

[к оглавлению](#Реактивность)

## Основные виды потерь на блокирующем типе программирования

В блокирующем типе программирования в веб-разработке могут возникать различные виды потерь, связанные с ожиданием 
завершения операций ввода-вывода (I/O). Вот основные виды потерь на блокирующем типе программирования в вебе:

1. Ожидание ответа от внешних сервисов: Если веб-приложение выполняет запросы к внешним сервисам или базам данных с
использованием синхронных запросов, это может привести к блокированию потока выполнения до получения ответа. В 
результате это может привести к простою ресурсов и ухудшению отзывчивости приложения.

2. Блокировка при обращении к базам данных: Взаимодействие с базами данных с использованием блокирующих операций
также может вызвать задержки. Например, долгие запросы к базе данных или блокирование на запись могут привести к 
замедлению работы веб-приложения.

3. Задержки при работе с файловой системой: Приложения, которые часто читают или записывают файлы на диск, могут 
столкнуться с блокирующими операциями ввода-вывода при работе с файловой системой. Это может вызвать замедление 
работы приложения, особенно при большом количестве одновременных запросов.

4. Ограниченное масштабирование: Блокирующий тип программирования может ограничивать возможности масштабирования 
приложения, особенно при большом количестве одновременных пользователей. Это связано с тем, что большое количество 
блокирующих операций может привести к исчерпанию ресурсов сервера.

5. Потеря ресурсов: В случае блокировки потоков выполнения из-за блокирующих операций могут происходить потери 
ресурсов процессора и памяти. Это может привести к неэффективному использованию ресурсов сервера.

6. Низкая отзывчивость и производительность: Блокирующий тип программирования может привести к низкой отзывчивости 
и производительности приложения, особенно при высокой нагрузке и большом количестве одновременных запросов.

[к оглавлению](#Реактивность)

## Понятие backpressure обратное давление. Что оно дает?
Backpressure - это концепция, используемая в реактивном программировании для управления потоком данных между компонентами системы. 
Она представляет собой механизм обратной связи, который позволяет компоненту, получающему данные, уведомлять поставщика 
данных о своей способности обрабатывать эти данные.

Когда компонент генерирует данные быстрее, чем компонент может их обрабатывать, это может привести к проблемам, таким 
как переполнение памяти, потеря данных или падение производительности. Backpressure позволяет избежать этих проблем, 
предоставляя механизм для контроля над потоком данных.

Как это работает:

1. Поставщик данных генерирует данные и отправляет их потребителю.

2. Потребитель может сообщать поставщику, насколько быстро он может обрабатывать данные, используя механизм обратной связи.

3. Если поставщик отправляет данные быстрее, чем потребитель может их обрабатывать, потребитель отправляет сигнал backpressure, 
указывающий на то, что следует временно остановить или замедлить производство данных.

4. Поставщик реагирует на сигнал backpressure, приостанавливая или замедляя производство данных до тех пор, пока потребитель 
не сможет обработать более крупный объем данных.

Это позволяет сбалансировать скорость производства и потребления данных, обеспечивая более эффективное использование ресурсов 
и предотвращая перегрузку компонентов системы.

Таким образом, backpressure позволяет сделать реактивные системы более устойчивыми, улучшая их производительность и отзывчивость при обработке потоков данных.

[к оглавлению](#Реактивность)
## При-каком-количестве-запросов-и-нагрузке-имеет-реактивно
Определить точное количество запросов или уровень нагрузки, при котором реактивно построенное приложение начинает выигрывать 
у приложения с блокирующим типом запросов, довольно сложно, поскольку это зависит от множества факторов, таких как архитектура приложения, 
типы операций ввода-вывода, ресурсы сервера и т. д.

Однако можно предположить, что реактивное приложение начнет показывать преимущества над блокирующим типом приблизительно в следующих случаях:

1. Высокая нагрузка и большое количество одновременных запросов: Когда количество одновременных запросов становится очень 
большим, реактивное приложение может эффективнее обрабатывать эту нагрузку, так как асинхронный и неблокирующий подход 
позволяет лучше использовать ресурсы сервера и обрабатывать запросы параллельно.

2. Долгие операции ввода-вывода: Если приложение часто выполняет долгие операции ввода-вывода, такие как запросы к базе 
данных, работа с файловой системой или взаимодействие с внешними сервисами, то реактивное приложение может более эффективно
использовать ресурсы за счет асинхронности и неблокирующей обработки.

3. Неоднородная нагрузка: Если нагрузка на приложение изменяется с течением времени, то реактивное приложение может лучше 
адаптироваться к изменениям, так как оно способно эластично масштабироваться и обрабатывать изменяющийся объем работы.

Оценка, при каком количестве запросов или уровне нагрузки реактивное приложение начинает выигрывать у блокирующего, может быть 
проведена экспериментально с использованием нагрузочного тестирования и профилирования приложений. В конечном счете, решение о 
переходе к реактивной архитектуре должно основываться на конкретных требованиях проекта, его целях и ожидаемых нагрузках.

[к оглавлению](#Реактивность)

## Основные библиотеки

ChatGPT
Для реализации реактивного программирования в Java и JVM-экосистеме существует несколько основных библиотек и фреймворков. Вот некоторые из них:

1. Project Reactor: Это библиотека реактивного программирования для Java, разработанная Pivotal (теперь VMware). Она 
предоставляет инструменты для работы с реактивными потоками данных, такими как Flux (поток данных) и Mono (поток данных 
с нулевым или одним элементом).

2. RxJava: Это реализация реактивного программирования на основе паттерна "Observable" для языка Java. RxJava предоставляет
мощный и гибкий API для работы с асинхронными и событийно-ориентированными потоками данных.

3. Akka Streams: Это часть Akka Toolkit, предоставляющая высокоуровневый API для композиции и обработки асинхронных потоков 
данных с использованием акторной модели.

4. Spring WebFlux: Это фреймворк от Spring для разработки реактивных веб-приложений. Он основан на Project Reactor и 
предоставляет аннотации и инструменты для создания реактивных контроллеров и служб.

5. Vert.x: Это асинхронный и реактивный фреймворк, предназначенный для разработки высокопроизводительных веб-приложений 
и микросервисов. Он предоставляет асинхронную модель программирования с использованием event-driven подхода.

6. Ratpack: Это фреймворк для создания реактивных веб-приложений на основе Groovy и Java. Он предоставляет высокоуровневый 
API для обработки HTTP-запросов и работы с асинхронными потоками данных.

Эти библиотеки предоставляют различные инструменты и подходы к реализации реактивного программирования в Java и JVM-экосистеме.
Выбор конкретной библиотеки зависит от требований вашего проекта, опыта команды разработчиков и предпочтений в использовании фреймворков.

[к оглавлению](#Реактивность)








