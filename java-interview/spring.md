[Вопросы для собеседования](../README.md)

# Spring

+ [Суть паттерна DI IOC](spring.md#Суть-паттерна-DI-IOC)
+ [Что такое _Spring_?](spring.md#Что-такое-spring)
+ [Что такое _AOP?_ Как это относиться к _IoC?_](spring.md#Что-такое-AOP-Как-это-относиться-к-IoC)
+ [Какие вы знаете различные scope у Spring _Bean?_](spring.md#Какие-вы-знаете-различные-scope-у-Spring-Bean)
+ [Что такое _бин?_](spring.md#Что-такое-бин)
+ [Что такое жизненный цикл Spring _Bean?_](spring.md#Что-такое-жизненный-цикл-Spring-Bean)
+ [Каким образом можно управлять транзакциями в _Spring?_](spring.md#Каким-образом-можно-управлять-транзакциями-в-Spring)
+ [Какая разница между аннотациями @Component, @Repository и @Service в _Spring?_](spring.md#Какая-разница-между-аннотациями-Component-Repository-и-Service-в-Spring)
+ [Чем отличается Bean от _Component?_](spring.md#Чем-отличается-Bean-от-Component)
+ [В чём состоит различие между Spring и Spring _Boot?_](spring.md#В-чём-состоит-различие-между-Spring-и-Spring-Boot)
+ [@Transactional](spring.md#Transactional)
+ [Разница между JDBC, JPA, Hibernate, Spring Data Jpa](spring.md#JDBC-JPA-Hibernate-Spring-Data-Jpa)
+ [Что такое Spring _MVC?_](spring.md#Что-такое-spring-mvc)
+ [Определение Контроллера](spring.md#определение-контроллера)
+ [@RestController vs @Controller](spring.md#RestController-vs-Controller)

## Суть паттерна DI IOC
IoC - аутсорсинг созадния и управления объектами. Т.е. передача программистом прав на создание
и управление объектами Спрнинг

DI - аутсорсинг добавление/внедрение зависимостей. DI делает объекты нашего приложения 
слобосвязанными

[к оглавлению](#Spring)

## Что такое _Spring_?
Spring - фреймворк с открытым исходным кодом, предназначеный для упрощения разработки enterprise-приложений. Одним из главным преимуществом Spring является его слоистая архитектура, позволяющая вам самим определять какие компоненты будут использованы в вашем приложении. Модули Spring построены на базе основного контейнера, который определяет создание, конфигурация и менеджмент бинов.
Основной контейнер - предоставляет основной функционал Spring. Главным компонентом контейнера является BeanFactory - реализация паттерна Фабрика. BeanFactory позволяет разделить конфигурацию приложения и информацию о зависимостях от кода.
Spring context - конфигурационный файл, который предоставляет информация об окружающей среде для Spring. Сюда входят такие enterprise-сервисы, как JNDI, EJB, интернационализация, валиадция и т.п.
Spring AOP - отвечает за интеграцию аспектно-ориентированного программирования во фреймворк. Spring AOP обеспечивает сервис управления транзакциями для Spring-приложения.
Spring DAO - абстрактный уровень Spring JDBC DAO предоставляет иерархию исключений и множество сообщений об ошибках для разных БД. Эта иерархия упрощает обработку исключений и значительно уменьшает количество кода, которое вам нужно было бы написать для таких операций, как, например, открытие и закрытие соединения.
Spring ORM - отвечает за интеграцию Spring и таких популярных ORM-фреймворков, как Hibernate, iBatis и JDO.
Spring Web module - классы, которые помогают упростить разработку Web (авторизация, доступ к бинам Spring-а из web).

[к оглавлению](#Spring)

## Что такое _AOP?_ Как это относиться к _IoC?_
Аспектно-ориентированное программирование (АОП) - парадигма программирования, основанная на идее разделения 
функциональности для улучшения разбиения программы на модули. AOP и Spring - взаимодополняющие технологии, 
которые позволяют решать сложные проблемы путем разделения функционала на отдельные модули. АОП предоставляет 
возможность реализации сквозной логики - т.е. логики, которая применяется к множеству частей приложения - в 
одном месте и обеспечения автоматического применения этой логики по всему приложению. Подход Spring к АОП 
заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к 
конфигурированному совету для выполнения сквозной логики.

[к оглавлению](#Spring)

## Какие вы знаете различные scope у Spring _Bean?_

В Spring предусмотрены различные области времени действия бинов:

__Singleton__ может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое.
Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.

__Prototype__ создается новый экземпляр при каждом запросе.

__Request__ аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. 
Создается новый экземпляр при каждом HTTP request.

__Session__ новый бин создается в контейнере при каждой новой HTTP сессии.
global-session: используется для создания глобальных бинов на уровне сессии для Portlet  приложений.

[к оглавлению](#Spring)

## Что такое _бин?_

В Spring-е бином (bean) называют любой класс, который управляется контейнером Spring. 
То есть такими вещами, как создание экземпляра бина, его инициализация, внедрение 
зависимостей и параметров, деинициализация, генерация всевозможных оберток над бином, 
занимается не ваш код, а IoC-контейнер Spring-а.

[к оглавлению](#Spring)

## Что такое жизненный цикл Spring _Bean?_

Жизненный цикл Spring Bean - время существования класса. Spring бины инициализируются при инициализации Spring контейнера и происходит внедрение 
всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё содержимое. Если нам необходимо задать 
какое-либо действие при инициализации и уничтожении бина, то нужно воспользоваться методами init() и destroy(). 
Для этого можно использовать аннотации @PostConstruct и @PreDestroy().

![icon](resources/bean_life.png)

[к оглавлению](#Spring)

## Каким образом можно управлять транзакциями в _Spring?_

Транзакциями в Spring управляют с помощью Declarative Transaction Management (программное управление). 
Используется аннотация @Transactional для описания необходимости управления транзакцией. В файле конфигурации 
нужно добавить настройку transactionManager для DataSource.

[к оглавлению](#Spring)

## Какая разница между аннотациями @Component, @Repository и @Service в _Spring?_

Spring @Component, @Service, @Repository и @Controller аннотации используются для сканирования указанного класса пути, 
зарегистрированного как bean-компонент в среде Spring. @Component - это общая аннотация.
Разница между @Service, @Repository, @Controller и @Component заключается в том, что они являются частными случаями 
@Component и используются для определенных целей. Разница только в классификации.

__@Component__ - используется для указания класса в качестве компонента spring. При использовании поиска аннотаций, 
такой класс будет сконфигурирован как spring bean.

__@Controller__ - специальный тип класса, применяемый в MVC приложениях. Обрабатывает запросы и часто используется 
с аннотацией @RequestMapping.

__@Repository__ - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация 
может использоваться для реализации шаблона DAO.

__@Service__ - указывает, что класс является сервисом для реализации бизнес логики (на самом деле не отличается от 
Component, но просто помогает разработчику указать смысловую нагрузку класса).

Для указания контейнеру на класс-бин можно использовать любую из этих аннотаций. Но различные имена позволяют 
различать назначение того или иного класса.

[к оглавлению](#Spring)

##  Чем отличается Bean от _Component?_
__@Component (и @Service и @Repository)__ используются для автоматического обнаружения и 
автоматической настройки beans с помощью сканирования пути к классам. Существует неявное
взаимно однозначное сопоставление между аннотированным классом и bean 
(т.е. Один bean для каждого класса). Управление проводкой довольно ограничено этим 
подходом, поскольку оно чисто декларативное.

__@Bean__ используется для явного объявления одного bean, а не для Spring делать это 
автоматически, как указано выше. Он отделяет объявление bean от определения класса и 
позволяет вам создавать и настраивать beans точно, как вы выбираете. @Bean аннотация 
возвращает объект, который spring должен регистрироваться как bean в контексте 
приложения. тело метода несет логику, ответственную за создание экземпляра.

[к оглавлению](#Spring)

## В чём состоит различие между Spring и Spring _Boot?_
__Spring Boot__ – это один из многочисленных проектов экосистемы Spring, но в отличие от большинства 
своих «собратьев» он не решает какую-либо конкретную задачу, а представляет собой скорее новый этап
развития Spring в целом.

Цель Spring Boot состоит в том, чтобы упростить процесс разработки приложений на основе Spring при
помощи их создания на основе уже готовых «наборов» программных компонентов (так называемых, 
«starter» пакетов), которые уже включают «джентельменский» набор того, что необходимо для решения
той или иной задачи и сконфигурированы соответствующим образом.

Это избавляет программиста не только от написания длинных конфигурационных файлов (особенно в XML),
но и от необходимости настраивать различные компоненты для совместной работы. Что позволяет 
сосредоточиться на написании прикладного кода.

Если конфигурация по умолчанию, вас в чём-то не устраивает, также можно самостоятельно сконфигурировать
нужные компоненты написав соответствующий класс конфигурации. Конфигурации из этого класса переопределит
конфигурацию, заданную по умолчанию для соответствующих компонентов, что позволяет в случае необходимости
полностью настроить приложение «под проект».

__Наиболее часто используемые starter пакеты:__

__Spring boot starter web__ 

Включает компоненты для создания web приложений или backend REST сервисов (работает на основе Spring MVC);

__Spring boot starter data JPA__

Включает компоненты для работы с базами данных в соответствии с подходом ORM (работает на основе 
Hibernate);

__Spring boot starter test__

Включает компоненты для автоматизированного (Unit) тестирования приложений (работает на основе Junit и Mockito).
Это далеко не всё, что может предложить Spring Boot на сегодняшний день. Существуют также starter
пакеты для многих других задач. Например, выполнения заданий по расписанию (на основе Spring Quartz),
работы с электронной почтой, диагностики работы приложений и т.д.

Также Spring Boot включается в себя переносную версию сервера приложений Tomcat. Что даёт собирать 
standalone приложения и тем самым обойтись без развёртывания специального сервера для работы 
приложений и значительно упрощает их контейнеризацию в тот же Docker.

В настоящее время Spring Boot уже почти полностью вытеснил «классические» приложения Spring в 
качестве основы для новых проектов.

[к оглавлению](#Spring)

## @Transactional

__Транзакцией__ называется набор связанных операций, все из которых должны быть выполнены
корректно без ошибок. Если при выполнении одной из операций возникла ошибка, все 
остальные должны быть отменены. Прежде всего такой механизм применяется при работе с БД.

Spring предлагает очень простой декларативный способ управления транзакциями. Вам достаточно
добавить @org.springframework.transaction.annotation. Transactional к публичному сервисному
методу, и все операции внутри этого метода будут выполняться в транзакции. При выходе из 
метода транзакция будет завершена (операция commit в терминах БД) автоматически. Если в 
процессе работы возникнет исключение и оно не будет перехвачено внутри метода, транзакция
будет отменена (операция rollback) и все данные вернуться в то состояние, в котором они 
были до начала транзакции.

[к оглавлению](#Spring)

## JDBC, JPA, Hibernate, Spring Data Jpa
__JDBC__ — это мост между миром Java и миром баз данных. Ведь первое, что мы ищем когда хотим 
подключить базу данных к нашему приложению — jdbc драйвер. Если мы работаем с Maven, тогда мы 
ищем зависимость для драйвера к определенной базе.

Одним из недостатков JDBC является то, что код, который получается в конце — выглядит очень большим
по объему (хотя работы он выполняет не много). Также, очень сложно приходится, когда объект джава 
который мы пытаемся сохранить в базе или достать — достаточно большой.

JPA призвана устранить вышеперечисленные недостатки.

__Java Persistence API__ — это технология, которая позволяет удобно мапить объект Java и таблицу 
базы данных. В JDBC при написании каждого запроса, Вам необходимо указать в коде все детали, 
необходимые для операций CRUD, такие как имена таблиц, имена столбцов. В JPA (которая использует 
JDBC «под капотом») Вы также указываете эти данные, но уже только один раз, когда навешиваете 
аннотации на Java класс. Сама по себе спецификация JPA не является инструментом или фреймворком; скорее, она определяет 
набор концепций, которые могут и должны быть реализованы любым другим инструментом.
Так как JPA — это просто спецификация, Вам нужен инструмент для ее реализации. Этим инструментом 
может быть Hibernate, TopLink, iBatis и т. д.

__Hibernate__ самый популярный ORM (Object Relational Mapping) фреймворк для работы с базой данных.
Вы можете рассматривать JPA как интерфейс, а Hibernate — как реализацию. Без Hibernate, от JPA в 
Вашем коде будет мало полезности. Хотя как Hibernate так и JPA можно использовать по отдельности в 
связке с другими инструментами.

Цель Spring Data — уменьшить объем стандартного кода, необходимого для реализации уровней доступа к данным 
для различных баз данных.

__Spring Data JPA__ — это библиотека, которая добавляет дополнительный уровень абстракции поверх 
ORM реализации JPA. По умолчанию Spring Data JPA использует Hibernate, в качестве ORM провайдера 
(чтобы выполнять запросы). Это, кстати, можно изменить используя настройки Spring. Хотя делать 
это неопытным пользователям я бы не советовал.

Если Вы используете Spring Boot вместе с Spring Data JPA, то имеете все необходимые настройки 
подключения Java приложения к базе данных “из коробки”. Единственное, что нужно указать — это 
хост для Вашей базы данных, имя пользователя и пароль для доступа к ней. Spring Boot обеспечивает 
автоматическую настройку для всего подключения к базе. В том числе и пул соединений.

![icon](resources/jpa-jdbc.png)

[к оглавлению](#Spring)

## Что такое Spring _MVC?_

<img src="./resources/s_mvc.jpg" width="500" height="400"/>

Фреймворк Spring MVC обеспечивает архитектуру паттерна Model — View — Controller (Модель — Отображение (далее — Вид) — Контроллер) 
при помощи слабо связанных готовых компонентов. Паттерн MVC разделяет аспекты приложения (логику ввода, бизнес-логику и логику UI), 
обеспечивая при этом свободную связь между ними.

* **Model** (Модель) инкапсулирует (объединяет) данные приложения, в целом они будут состоять из POJO («Старых добрых 
  Java-объектов», или бинов).


* **View** (Отображение, Вид) отвечает за отображение данных Модели, — как правило, генерируя HTML, которые мы видим в своём браузере.


* **Controller** (Контроллер) обрабатывает запрос пользователя, создаёт соответствующую Модель и передаёт её для отображения в Вид.


###DispatcherServlet

Вся логика работы Spring MVC построена вокруг DispatcherServlet, который принимает и обрабатывает все HTTP-запросы 
(из UI) и ответы на них. Рабочий процесс обработки запроса DispatcherServlet'ом проиллюстрирован на следующей диаграмме:

<img src="./resources/dispatcherServlet.png" width="500" height="400"/>

1. После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой 
   Контроллер должен быть вызван, после чего, отправляет запрос в нужный Контроллер.
   

2. Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST. Вызванный метод 
   определяет данные Модели, основанные на определённой бизнес-логике и возвращает в DispatcherServlet имя Вида (View).


3. При помощи интерфейса ViewResolver DispatcherServlet определяет, какой Вид нужно использовать на основании полученного имени.


4. После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид, который в 
   конечном итоге отображается в браузере.

Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver, являются частями интерфейса 
WebApplicationContext extends ApplicationContext, с некоторыми дополнительными особенностями, необходимыми для создания 
web-приложений.

(Взято от сюда https://habr.com/ru/post/336816/)

[к оглавлению](#Spring)

## Определение Контроллера

DispatcherServlet отправляет запрос контроллерам для выполнения определённых функций. Аннотация @Controllerannotation 
указывает, что конкретный класс является контроллером. Аннотация @RequestMapping используется для мапинга (связывания)
с URL для всего класса или для конкретного метода обработчика.

```java
@Controller
@RequestMapping("/hello")
public class HelloController { 
   @RequestMapping(method = RequestMethod.GET)
   public String printHello(ModelMap model) {
      model.addAttribute("message", "Hello Spring MVC Framework!");
      return "hello";
   }
}
```

Аннотация Controller определяет класс как Контроллер Spring MVC. В первом случае, @RequestMapping указывает, что все 
методы в данном Контроллере относятся к URL-адресу "/hello". Следующая аннотация @RequestMapping(method = RequestMethod.GET)
используется для объявления метода printHello() как дефолтного метода для обработки HTTP-запросов GET (в данном Контроллере).
Вы можете определить любой другой метод как обработчик всех POST-запросов по данному URL-адресу.

Вы можете написать вышеуказанный Контроллер по-другому, указав дополнительные атрибуты для аннотации @RequestMapping следующим образом:

```java
@Controller
public class HelloController {
   @RequestMapping(value = "/hello", method = RequestMethod.GET)
   public String printHello(ModelMap model) {
      model.addAttribute("message", "Hello Spring MVC Framework!");
      return "hello";
   }
}
```

Атрибут «value» указывает URL, с которым мы связываем данный метод (value = "/hello"), далее указывается, что этот метод
будет обрабатывать GET-запросы (method = RequestMethod.GET). Также, нужно отметить важные моменты в отношении приведённого
выше контроллера:

* Вы определяете бизнес-логику внутри связанного таким образом служебного метода. Из него Вы можете вызывать любые другие методы.


* Основываясь на заданной бизнес-логике, в рамках этого метода Вы создаёте Модель (Model). Вы можете добавлять аттрибуты 
  Модели, которые будут добавлены в Вид (View). В примере выше мы создаём Модель с атрибутом «message».


* Данный служебный метод возвращает имя Вида в виде строки String. В данном случае, запрашиваемый Вид имеет имя «hello».

[к оглавлению](#Spring)
## @RestController vs @Controller
Аннотация ``@RestController`` в Spring MVC — это не что иное, как сочетание аннотации ``@Controller`` и ``@ResponseBody``. 
Он был добавлен в Spring 4.0 для упрощения разработки веб-служб RESTful в среде Spring. Если вы знакомы с веб-службами REST, 
вы знаете, что принципиальное различие между веб-приложением и API-интерфейсом REST заключается в том, что ответ 
веб-приложения представляет собой общий вид HTML + CSS + JavaScript, тогда как API-интерфейс REST просто возвращает 
данные в форме JSON или XML. Эта разница также очевидна в аннотации ``@Controller`` и ``@RestController``. 
Задача ``@Controller`` — создать карту объекта модели и найти представление, но @RestController просто возвращает объект, 
и данные объекта напрямую записываются в HTTP-ответ в виде JSON или XML.

Это также можно сделать с помощью традиционного ``@Controller`` и использования аннотации ``@ResponseBody`` но так как это
стандартное поведение веб-сервисов RESTful, Spring представил ``@RestController`` который сочетал в себе поведение 
``@Controller`` и ``@ResponseBody``.

Вкратце, следующие два фрагмента кода в Spring MVC равны:

```java

@Controller
@ResponseBody
public class MVCController {
   .. your logic
}

@RestController
public class RestFulController {
  .... your logic
}
```


[к оглавлению](#Spring)
